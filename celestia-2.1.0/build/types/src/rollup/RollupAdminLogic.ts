/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export type GlobalStateStruct = {
  bytes32Vals: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>];
  u64Vals: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
};

export type GlobalStateStructOutput = [
  [string, string],
  [BigNumber, BigNumber]
] & { bytes32Vals: [string, string]; u64Vals: [BigNumber, BigNumber] };

export type ExecutionStateStruct = {
  globalState: GlobalStateStruct;
  machineStatus: PromiseOrValue<BigNumberish>;
};

export type ExecutionStateStructOutput = [GlobalStateStructOutput, number] & {
  globalState: GlobalStateStructOutput;
  machineStatus: number;
};

export type AssertionStruct = {
  beforeState: ExecutionStateStruct;
  afterState: ExecutionStateStruct;
  numBlocks: PromiseOrValue<BigNumberish>;
};

export type AssertionStructOutput = [
  ExecutionStateStructOutput,
  ExecutionStateStructOutput,
  BigNumber
] & {
  beforeState: ExecutionStateStructOutput;
  afterState: ExecutionStateStructOutput;
  numBlocks: BigNumber;
};

export type NodeStruct = {
  stateHash: PromiseOrValue<BytesLike>;
  challengeHash: PromiseOrValue<BytesLike>;
  confirmData: PromiseOrValue<BytesLike>;
  prevNum: PromiseOrValue<BigNumberish>;
  deadlineBlock: PromiseOrValue<BigNumberish>;
  noChildConfirmedBeforeBlock: PromiseOrValue<BigNumberish>;
  stakerCount: PromiseOrValue<BigNumberish>;
  childStakerCount: PromiseOrValue<BigNumberish>;
  firstChildBlock: PromiseOrValue<BigNumberish>;
  latestChildNumber: PromiseOrValue<BigNumberish>;
  createdAtBlock: PromiseOrValue<BigNumberish>;
  nodeHash: PromiseOrValue<BytesLike>;
};

export type NodeStructOutput = [
  string,
  string,
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  string
] & {
  stateHash: string;
  challengeHash: string;
  confirmData: string;
  prevNum: BigNumber;
  deadlineBlock: BigNumber;
  noChildConfirmedBeforeBlock: BigNumber;
  stakerCount: BigNumber;
  childStakerCount: BigNumber;
  firstChildBlock: BigNumber;
  latestChildNumber: BigNumber;
  createdAtBlock: BigNumber;
  nodeHash: string;
};

export type ConfigStruct = {
  confirmPeriodBlocks: PromiseOrValue<BigNumberish>;
  extraChallengeTimeBlocks: PromiseOrValue<BigNumberish>;
  stakeToken: PromiseOrValue<string>;
  baseStake: PromiseOrValue<BigNumberish>;
  wasmModuleRoot: PromiseOrValue<BytesLike>;
  owner: PromiseOrValue<string>;
  loserStakeEscrow: PromiseOrValue<string>;
  chainId: PromiseOrValue<BigNumberish>;
  chainConfig: PromiseOrValue<string>;
  genesisBlockNum: PromiseOrValue<BigNumberish>;
  sequencerInboxMaxTimeVariation: ISequencerInbox.MaxTimeVariationStruct;
};

export type ConfigStructOutput = [
  BigNumber,
  BigNumber,
  string,
  BigNumber,
  string,
  string,
  string,
  BigNumber,
  string,
  BigNumber,
  ISequencerInbox.MaxTimeVariationStructOutput
] & {
  confirmPeriodBlocks: BigNumber;
  extraChallengeTimeBlocks: BigNumber;
  stakeToken: string;
  baseStake: BigNumber;
  wasmModuleRoot: string;
  owner: string;
  loserStakeEscrow: string;
  chainId: BigNumber;
  chainConfig: string;
  genesisBlockNum: BigNumber;
  sequencerInboxMaxTimeVariation: ISequencerInbox.MaxTimeVariationStructOutput;
};

export type ContractDependenciesStruct = {
  bridge: PromiseOrValue<string>;
  sequencerInbox: PromiseOrValue<string>;
  inbox: PromiseOrValue<string>;
  outbox: PromiseOrValue<string>;
  rollupEventInbox: PromiseOrValue<string>;
  challengeManager: PromiseOrValue<string>;
  rollupAdminLogic: PromiseOrValue<string>;
  rollupUserLogic: PromiseOrValue<string>;
  validatorUtils: PromiseOrValue<string>;
  validatorWalletCreator: PromiseOrValue<string>;
};

export type ContractDependenciesStructOutput = [
  string,
  string,
  string,
  string,
  string,
  string,
  string,
  string,
  string,
  string
] & {
  bridge: string;
  sequencerInbox: string;
  inbox: string;
  outbox: string;
  rollupEventInbox: string;
  challengeManager: string;
  rollupAdminLogic: string;
  rollupUserLogic: string;
  validatorUtils: string;
  validatorWalletCreator: string;
};

export declare namespace IRollupCore {
  export type StakerStruct = {
    amountStaked: PromiseOrValue<BigNumberish>;
    index: PromiseOrValue<BigNumberish>;
    latestStakedNode: PromiseOrValue<BigNumberish>;
    currentChallenge: PromiseOrValue<BigNumberish>;
    isStaked: PromiseOrValue<boolean>;
  };

  export type StakerStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    amountStaked: BigNumber;
    index: BigNumber;
    latestStakedNode: BigNumber;
    currentChallenge: BigNumber;
    isStaked: boolean;
  };
}

export declare namespace ISequencerInbox {
  export type MaxTimeVariationStruct = {
    delayBlocks: PromiseOrValue<BigNumberish>;
    futureBlocks: PromiseOrValue<BigNumberish>;
    delaySeconds: PromiseOrValue<BigNumberish>;
    futureSeconds: PromiseOrValue<BigNumberish>;
  };

  export type MaxTimeVariationStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    delayBlocks: BigNumber;
    futureBlocks: BigNumber;
    delaySeconds: BigNumber;
    futureSeconds: BigNumber;
  };
}

export interface RollupAdminLogicInterface extends utils.Interface {
  functions: {
    "_stakerMap(address)": FunctionFragment;
    "amountStaked(address)": FunctionFragment;
    "anyTrustFastConfirmer()": FunctionFragment;
    "baseStake()": FunctionFragment;
    "bridge()": FunctionFragment;
    "chainId()": FunctionFragment;
    "challengeManager()": FunctionFragment;
    "confirmPeriodBlocks()": FunctionFragment;
    "createNitroMigrationGenesis((((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64))": FunctionFragment;
    "currentChallenge(address)": FunctionFragment;
    "extraChallengeTimeBlocks()": FunctionFragment;
    "firstUnresolvedNode()": FunctionFragment;
    "forceConfirmNode(uint64,bytes32,bytes32)": FunctionFragment;
    "forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)": FunctionFragment;
    "forceRefundStaker(address[])": FunctionFragment;
    "forceResolveChallenge(address[],address[])": FunctionFragment;
    "getNode(uint64)": FunctionFragment;
    "getNodeCreationBlockForLogLookup(uint64)": FunctionFragment;
    "getStaker(address)": FunctionFragment;
    "getStakerAddress(uint64)": FunctionFragment;
    "inbox()": FunctionFragment;
    "initialize((uint64,uint64,address,uint256,bytes32,address,address,uint256,string,uint64,(uint256,uint256,uint256,uint256)),(address,address,address,address,address,address,address,address,address,address))": FunctionFragment;
    "isStaked(address)": FunctionFragment;
    "isStakedOnLatestConfirmed(address)": FunctionFragment;
    "isValidator(address)": FunctionFragment;
    "isZombie(address)": FunctionFragment;
    "lastStakeBlock()": FunctionFragment;
    "latestConfirmed()": FunctionFragment;
    "latestNodeCreated()": FunctionFragment;
    "latestStakedNode(address)": FunctionFragment;
    "loserStakeEscrow()": FunctionFragment;
    "minimumAssertionPeriod()": FunctionFragment;
    "nodeHasStaker(uint64,address)": FunctionFragment;
    "outbox()": FunctionFragment;
    "pause()": FunctionFragment;
    "paused()": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "removeOldOutbox(address)": FunctionFragment;
    "resume()": FunctionFragment;
    "rollupDeploymentBlock()": FunctionFragment;
    "rollupEventInbox()": FunctionFragment;
    "sequencerInbox()": FunctionFragment;
    "setAnyTrustFastConfirmer(address)": FunctionFragment;
    "setBaseStake(uint256)": FunctionFragment;
    "setConfirmPeriodBlocks(uint64)": FunctionFragment;
    "setDelayedInbox(address,bool)": FunctionFragment;
    "setExtraChallengeTimeBlocks(uint64)": FunctionFragment;
    "setInbox(address)": FunctionFragment;
    "setLoserStakeEscrow(address)": FunctionFragment;
    "setMinimumAssertionPeriod(uint256)": FunctionFragment;
    "setOutbox(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "setSequencerInbox(address)": FunctionFragment;
    "setStakeToken(address)": FunctionFragment;
    "setValidator(address[],bool[])": FunctionFragment;
    "setValidatorWhitelistDisabled(bool)": FunctionFragment;
    "setWasmModuleRoot(bytes32)": FunctionFragment;
    "stakeToken()": FunctionFragment;
    "stakerCount()": FunctionFragment;
    "totalWithdrawableFunds()": FunctionFragment;
    "upgradeBeacon(address,address)": FunctionFragment;
    "upgradeSecondaryTo(address)": FunctionFragment;
    "upgradeSecondaryToAndCall(address,bytes)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
    "validatorUtils()": FunctionFragment;
    "validatorWalletCreator()": FunctionFragment;
    "validatorWhitelistDisabled()": FunctionFragment;
    "wasmModuleRoot()": FunctionFragment;
    "withdrawableFunds(address)": FunctionFragment;
    "zombieAddress(uint256)": FunctionFragment;
    "zombieCount()": FunctionFragment;
    "zombieLatestStakedNode(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "_stakerMap"
      | "amountStaked"
      | "anyTrustFastConfirmer"
      | "baseStake"
      | "bridge"
      | "chainId"
      | "challengeManager"
      | "confirmPeriodBlocks"
      | "createNitroMigrationGenesis"
      | "currentChallenge"
      | "extraChallengeTimeBlocks"
      | "firstUnresolvedNode"
      | "forceConfirmNode"
      | "forceCreateNode"
      | "forceRefundStaker"
      | "forceResolveChallenge"
      | "getNode"
      | "getNodeCreationBlockForLogLookup"
      | "getStaker"
      | "getStakerAddress"
      | "inbox"
      | "initialize"
      | "isStaked"
      | "isStakedOnLatestConfirmed"
      | "isValidator"
      | "isZombie"
      | "lastStakeBlock"
      | "latestConfirmed"
      | "latestNodeCreated"
      | "latestStakedNode"
      | "loserStakeEscrow"
      | "minimumAssertionPeriod"
      | "nodeHasStaker"
      | "outbox"
      | "pause"
      | "paused"
      | "proxiableUUID"
      | "removeOldOutbox"
      | "resume"
      | "rollupDeploymentBlock"
      | "rollupEventInbox"
      | "sequencerInbox"
      | "setAnyTrustFastConfirmer"
      | "setBaseStake"
      | "setConfirmPeriodBlocks"
      | "setDelayedInbox"
      | "setExtraChallengeTimeBlocks"
      | "setInbox"
      | "setLoserStakeEscrow"
      | "setMinimumAssertionPeriod"
      | "setOutbox"
      | "setOwner"
      | "setSequencerInbox"
      | "setStakeToken"
      | "setValidator"
      | "setValidatorWhitelistDisabled"
      | "setWasmModuleRoot"
      | "stakeToken"
      | "stakerCount"
      | "totalWithdrawableFunds"
      | "upgradeBeacon"
      | "upgradeSecondaryTo"
      | "upgradeSecondaryToAndCall"
      | "upgradeTo"
      | "upgradeToAndCall"
      | "validatorUtils"
      | "validatorWalletCreator"
      | "validatorWhitelistDisabled"
      | "wasmModuleRoot"
      | "withdrawableFunds"
      | "zombieAddress"
      | "zombieCount"
      | "zombieLatestStakedNode"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "_stakerMap",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "amountStaked",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "anyTrustFastConfirmer",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "baseStake", values?: undefined): string;
  encodeFunctionData(functionFragment: "bridge", values?: undefined): string;
  encodeFunctionData(functionFragment: "chainId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "challengeManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "confirmPeriodBlocks",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "createNitroMigrationGenesis",
    values: [AssertionStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "currentChallenge",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "extraChallengeTimeBlocks",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "firstUnresolvedNode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "forceConfirmNode",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceCreateNode",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      AssertionStruct,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceRefundStaker",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "forceResolveChallenge",
    values: [PromiseOrValue<string>[], PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getNode",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNodeCreationBlockForLogLookup",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getStaker",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getStakerAddress",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "inbox", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [ConfigStruct, ContractDependenciesStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "isStaked",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStakedOnLatestConfirmed",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isZombie",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "lastStakeBlock",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "latestConfirmed",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "latestNodeCreated",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "latestStakedNode",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "loserStakeEscrow",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minimumAssertionPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nodeHasStaker",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "outbox", values?: undefined): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeOldOutbox",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "resume", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rollupDeploymentBlock",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rollupEventInbox",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sequencerInbox",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAnyTrustFastConfirmer",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBaseStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setConfirmPeriodBlocks",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setDelayedInbox",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setExtraChallengeTimeBlocks",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setInbox",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setLoserStakeEscrow",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinimumAssertionPeriod",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOutbox",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSequencerInbox",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakeToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setValidator",
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setValidatorWhitelistDisabled",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setWasmModuleRoot",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stakerCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalWithdrawableFunds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeBeacon",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeSecondaryTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeSecondaryToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "validatorUtils",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "validatorWalletCreator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "validatorWhitelistDisabled",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "wasmModuleRoot",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawableFunds",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "zombieAddress",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "zombieCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "zombieLatestStakedNode",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "_stakerMap", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "amountStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "anyTrustFastConfirmer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "baseStake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bridge", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "chainId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "challengeManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "confirmPeriodBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNitroMigrationGenesis",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentChallenge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "extraChallengeTimeBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "firstUnresolvedNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceConfirmNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceCreateNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceRefundStaker",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceResolveChallenge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNode", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNodeCreationBlockForLogLookup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getStaker", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getStakerAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "inbox", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isStaked", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isStakedOnLatestConfirmed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isZombie", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastStakeBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestConfirmed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestNodeCreated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "latestStakedNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loserStakeEscrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minimumAssertionPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nodeHasStaker",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "outbox", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeOldOutbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resume", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rollupDeploymentBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rollupEventInbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sequencerInbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAnyTrustFastConfirmer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBaseStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setConfirmPeriodBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDelayedInbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExtraChallengeTimeBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setInbox", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setLoserStakeEscrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinimumAssertionPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOutbox", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setSequencerInbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setValidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setValidatorWhitelistDisabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setWasmModuleRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stakeToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakerCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalWithdrawableFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeBeacon",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeSecondaryTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeSecondaryToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatorUtils",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatorWalletCreator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatorWhitelistDisabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wasmModuleRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawableFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zombieAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zombieCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zombieLatestStakedNode",
    data: BytesLike
  ): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "NodeConfirmed(uint64,bytes32,bytes32)": EventFragment;
    "NodeCreated(uint64,bytes32,bytes32,bytes32,tuple,bytes32,bytes32,uint256)": EventFragment;
    "NodeRejected(uint64)": EventFragment;
    "OwnerFunctionCalled(uint256)": EventFragment;
    "Paused(address)": EventFragment;
    "RollupChallengeStarted(uint64,address,address,uint64)": EventFragment;
    "RollupInitialized(bytes32,uint256)": EventFragment;
    "Unpaused(address)": EventFragment;
    "Upgraded(address)": EventFragment;
    "UpgradedSecondary(address)": EventFragment;
    "UserStakeUpdated(address,uint256,uint256)": EventFragment;
    "UserWithdrawableFundsUpdated(address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodeConfirmed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodeCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NodeRejected"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerFunctionCalled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RollupChallengeStarted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RollupInitialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpgradedSecondary"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserStakeUpdated"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UserWithdrawableFundsUpdated"
  ): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface NodeConfirmedEventObject {
  nodeNum: BigNumber;
  blockHash: string;
  sendRoot: string;
}
export type NodeConfirmedEvent = TypedEvent<
  [BigNumber, string, string],
  NodeConfirmedEventObject
>;

export type NodeConfirmedEventFilter = TypedEventFilter<NodeConfirmedEvent>;

export interface NodeCreatedEventObject {
  nodeNum: BigNumber;
  parentNodeHash: string;
  nodeHash: string;
  executionHash: string;
  assertion: AssertionStructOutput;
  afterInboxBatchAcc: string;
  wasmModuleRoot: string;
  inboxMaxCount: BigNumber;
}
export type NodeCreatedEvent = TypedEvent<
  [
    BigNumber,
    string,
    string,
    string,
    AssertionStructOutput,
    string,
    string,
    BigNumber
  ],
  NodeCreatedEventObject
>;

export type NodeCreatedEventFilter = TypedEventFilter<NodeCreatedEvent>;

export interface NodeRejectedEventObject {
  nodeNum: BigNumber;
}
export type NodeRejectedEvent = TypedEvent<
  [BigNumber],
  NodeRejectedEventObject
>;

export type NodeRejectedEventFilter = TypedEventFilter<NodeRejectedEvent>;

export interface OwnerFunctionCalledEventObject {
  id: BigNumber;
}
export type OwnerFunctionCalledEvent = TypedEvent<
  [BigNumber],
  OwnerFunctionCalledEventObject
>;

export type OwnerFunctionCalledEventFilter =
  TypedEventFilter<OwnerFunctionCalledEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RollupChallengeStartedEventObject {
  challengeIndex: BigNumber;
  asserter: string;
  challenger: string;
  challengedNode: BigNumber;
}
export type RollupChallengeStartedEvent = TypedEvent<
  [BigNumber, string, string, BigNumber],
  RollupChallengeStartedEventObject
>;

export type RollupChallengeStartedEventFilter =
  TypedEventFilter<RollupChallengeStartedEvent>;

export interface RollupInitializedEventObject {
  machineHash: string;
  chainId: BigNumber;
}
export type RollupInitializedEvent = TypedEvent<
  [string, BigNumber],
  RollupInitializedEventObject
>;

export type RollupInitializedEventFilter =
  TypedEventFilter<RollupInitializedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface UpgradedSecondaryEventObject {
  implementation: string;
}
export type UpgradedSecondaryEvent = TypedEvent<
  [string],
  UpgradedSecondaryEventObject
>;

export type UpgradedSecondaryEventFilter =
  TypedEventFilter<UpgradedSecondaryEvent>;

export interface UserStakeUpdatedEventObject {
  user: string;
  initialBalance: BigNumber;
  finalBalance: BigNumber;
}
export type UserStakeUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  UserStakeUpdatedEventObject
>;

export type UserStakeUpdatedEventFilter =
  TypedEventFilter<UserStakeUpdatedEvent>;

export interface UserWithdrawableFundsUpdatedEventObject {
  user: string;
  initialBalance: BigNumber;
  finalBalance: BigNumber;
}
export type UserWithdrawableFundsUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  UserWithdrawableFundsUpdatedEventObject
>;

export type UserWithdrawableFundsUpdatedEventFilter =
  TypedEventFilter<UserWithdrawableFundsUpdatedEvent>;

export interface RollupAdminLogic extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RollupAdminLogicInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    _stakerMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
        amountStaked: BigNumber;
        index: BigNumber;
        latestStakedNode: BigNumber;
        currentChallenge: BigNumber;
        isStaked: boolean;
      }
    >;

    amountStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    anyTrustFastConfirmer(overrides?: CallOverrides): Promise<[string]>;

    baseStake(overrides?: CallOverrides): Promise<[BigNumber]>;

    bridge(overrides?: CallOverrides): Promise<[string]>;

    chainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    challengeManager(overrides?: CallOverrides): Promise<[string]>;

    confirmPeriodBlocks(overrides?: CallOverrides): Promise<[BigNumber]>;

    createNitroMigrationGenesis(
      assertion: AssertionStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    currentChallenge(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<[BigNumber]>;

    firstUnresolvedNode(overrides?: CallOverrides): Promise<[BigNumber]>;

    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceRefundStaker(
      staker: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceResolveChallenge(
      stakerA: PromiseOrValue<string>[],
      stakerB: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[NodeStructOutput]>;

    getNodeCreationBlockForLogLookup(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getStaker(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[IRollupCore.StakerStructOutput]>;

    getStakerAddress(
      stakerNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    inbox(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isStakedOnLatestConfirmed(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isValidator(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isZombie(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    lastStakeBlock(overrides?: CallOverrides): Promise<[BigNumber]>;

    latestConfirmed(overrides?: CallOverrides): Promise<[BigNumber]>;

    latestNodeCreated(overrides?: CallOverrides): Promise<[BigNumber]>;

    latestStakedNode(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    loserStakeEscrow(overrides?: CallOverrides): Promise<[string]>;

    minimumAssertionPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    nodeHasStaker(
      nodeNum: PromiseOrValue<BigNumberish>,
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    outbox(overrides?: CallOverrides): Promise<[string]>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resume(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rollupDeploymentBlock(overrides?: CallOverrides): Promise<[BigNumber]>;

    rollupEventInbox(overrides?: CallOverrides): Promise<[string]>;

    sequencerInbox(overrides?: CallOverrides): Promise<[string]>;

    setAnyTrustFastConfirmer(
      _anyTrustFastConfirmer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setInbox(
      newInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakeToken(overrides?: CallOverrides): Promise<[string]>;

    stakerCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalWithdrawableFunds(overrides?: CallOverrides): Promise<[BigNumber]>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeSecondaryTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeSecondaryToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validatorUtils(overrides?: CallOverrides): Promise<[string]>;

    validatorWalletCreator(overrides?: CallOverrides): Promise<[string]>;

    validatorWhitelistDisabled(overrides?: CallOverrides): Promise<[boolean]>;

    wasmModuleRoot(overrides?: CallOverrides): Promise<[string]>;

    withdrawableFunds(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    zombieAddress(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    zombieCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    zombieLatestStakedNode(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  _stakerMap(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
      amountStaked: BigNumber;
      index: BigNumber;
      latestStakedNode: BigNumber;
      currentChallenge: BigNumber;
      isStaked: boolean;
    }
  >;

  amountStaked(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  anyTrustFastConfirmer(overrides?: CallOverrides): Promise<string>;

  baseStake(overrides?: CallOverrides): Promise<BigNumber>;

  bridge(overrides?: CallOverrides): Promise<string>;

  chainId(overrides?: CallOverrides): Promise<BigNumber>;

  challengeManager(overrides?: CallOverrides): Promise<string>;

  confirmPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>;

  createNitroMigrationGenesis(
    assertion: AssertionStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  currentChallenge(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<BigNumber>;

  firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;

  forceConfirmNode(
    nodeNum: PromiseOrValue<BigNumberish>,
    blockHash: PromiseOrValue<BytesLike>,
    sendRoot: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceCreateNode(
    prevNode: PromiseOrValue<BigNumberish>,
    prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
    assertion: AssertionStruct,
    expectedNodeHash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceRefundStaker(
    staker: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceResolveChallenge(
    stakerA: PromiseOrValue<string>[],
    stakerB: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getNode(
    nodeNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<NodeStructOutput>;

  getNodeCreationBlockForLogLookup(
    nodeNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getStaker(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IRollupCore.StakerStructOutput>;

  getStakerAddress(
    stakerNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  inbox(overrides?: CallOverrides): Promise<string>;

  initialize(
    config: ConfigStruct,
    connectedContracts: ContractDependenciesStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isStaked(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isStakedOnLatestConfirmed(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isValidator(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isZombie(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;

  latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;

  latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;

  latestStakedNode(
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  loserStakeEscrow(overrides?: CallOverrides): Promise<string>;

  minimumAssertionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  nodeHasStaker(
    nodeNum: PromiseOrValue<BigNumberish>,
    staker: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  outbox(overrides?: CallOverrides): Promise<string>;

  pause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  removeOldOutbox(
    _outbox: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resume(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rollupDeploymentBlock(overrides?: CallOverrides): Promise<BigNumber>;

  rollupEventInbox(overrides?: CallOverrides): Promise<string>;

  sequencerInbox(overrides?: CallOverrides): Promise<string>;

  setAnyTrustFastConfirmer(
    _anyTrustFastConfirmer: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBaseStake(
    newBaseStake: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setConfirmPeriodBlocks(
    newConfirmPeriod: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDelayedInbox(
    _inbox: PromiseOrValue<string>,
    _enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setExtraChallengeTimeBlocks(
    newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setInbox(
    newInbox: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setLoserStakeEscrow(
    newLoserStakerEscrow: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinimumAssertionPeriod(
    newPeriod: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOutbox(
    _outbox: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSequencerInbox(
    _sequencerInbox: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakeToken(
    newStakeToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setValidator(
    _validator: PromiseOrValue<string>[],
    _val: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setValidatorWhitelistDisabled(
    _validatorWhitelistDisabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setWasmModuleRoot(
    newWasmModuleRoot: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakeToken(overrides?: CallOverrides): Promise<string>;

  stakerCount(overrides?: CallOverrides): Promise<BigNumber>;

  totalWithdrawableFunds(overrides?: CallOverrides): Promise<BigNumber>;

  upgradeBeacon(
    beacon: PromiseOrValue<string>,
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeSecondaryTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeSecondaryToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validatorUtils(overrides?: CallOverrides): Promise<string>;

  validatorWalletCreator(overrides?: CallOverrides): Promise<string>;

  validatorWhitelistDisabled(overrides?: CallOverrides): Promise<boolean>;

  wasmModuleRoot(overrides?: CallOverrides): Promise<string>;

  withdrawableFunds(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  zombieAddress(
    zombieNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  zombieCount(overrides?: CallOverrides): Promise<BigNumber>;

  zombieLatestStakedNode(
    zombieNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    _stakerMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
        amountStaked: BigNumber;
        index: BigNumber;
        latestStakedNode: BigNumber;
        currentChallenge: BigNumber;
        isStaked: boolean;
      }
    >;

    amountStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    anyTrustFastConfirmer(overrides?: CallOverrides): Promise<string>;

    baseStake(overrides?: CallOverrides): Promise<BigNumber>;

    bridge(overrides?: CallOverrides): Promise<string>;

    chainId(overrides?: CallOverrides): Promise<BigNumber>;

    challengeManager(overrides?: CallOverrides): Promise<string>;

    confirmPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    createNitroMigrationGenesis(
      assertion: AssertionStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    currentChallenge(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;

    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceRefundStaker(
      staker: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    forceResolveChallenge(
      stakerA: PromiseOrValue<string>[],
      stakerB: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    getNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<NodeStructOutput>;

    getNodeCreationBlockForLogLookup(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStaker(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IRollupCore.StakerStructOutput>;

    getStakerAddress(
      stakerNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    inbox(overrides?: CallOverrides): Promise<string>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    isStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isStakedOnLatestConfirmed(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isValidator(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isZombie(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;

    latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;

    latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;

    latestStakedNode(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loserStakeEscrow(overrides?: CallOverrides): Promise<string>;

    minimumAssertionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    nodeHasStaker(
      nodeNum: PromiseOrValue<BigNumberish>,
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    outbox(overrides?: CallOverrides): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    resume(overrides?: CallOverrides): Promise<void>;

    rollupDeploymentBlock(overrides?: CallOverrides): Promise<BigNumber>;

    rollupEventInbox(overrides?: CallOverrides): Promise<string>;

    sequencerInbox(overrides?: CallOverrides): Promise<string>;

    setAnyTrustFastConfirmer(
      _anyTrustFastConfirmer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setInbox(
      newInbox: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakeToken(overrides?: CallOverrides): Promise<string>;

    stakerCount(overrides?: CallOverrides): Promise<BigNumber>;

    totalWithdrawableFunds(overrides?: CallOverrides): Promise<BigNumber>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeSecondaryTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeSecondaryToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    validatorUtils(overrides?: CallOverrides): Promise<string>;

    validatorWalletCreator(overrides?: CallOverrides): Promise<string>;

    validatorWhitelistDisabled(overrides?: CallOverrides): Promise<boolean>;

    wasmModuleRoot(overrides?: CallOverrides): Promise<string>;

    withdrawableFunds(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    zombieAddress(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    zombieCount(overrides?: CallOverrides): Promise<BigNumber>;

    zombieLatestStakedNode(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "NodeConfirmed(uint64,bytes32,bytes32)"(
      nodeNum?: PromiseOrValue<BigNumberish> | null,
      blockHash?: null,
      sendRoot?: null
    ): NodeConfirmedEventFilter;
    NodeConfirmed(
      nodeNum?: PromiseOrValue<BigNumberish> | null,
      blockHash?: null,
      sendRoot?: null
    ): NodeConfirmedEventFilter;

    "NodeCreated(uint64,bytes32,bytes32,bytes32,tuple,bytes32,bytes32,uint256)"(
      nodeNum?: PromiseOrValue<BigNumberish> | null,
      parentNodeHash?: PromiseOrValue<BytesLike> | null,
      nodeHash?: PromiseOrValue<BytesLike> | null,
      executionHash?: null,
      assertion?: null,
      afterInboxBatchAcc?: null,
      wasmModuleRoot?: null,
      inboxMaxCount?: null
    ): NodeCreatedEventFilter;
    NodeCreated(
      nodeNum?: PromiseOrValue<BigNumberish> | null,
      parentNodeHash?: PromiseOrValue<BytesLike> | null,
      nodeHash?: PromiseOrValue<BytesLike> | null,
      executionHash?: null,
      assertion?: null,
      afterInboxBatchAcc?: null,
      wasmModuleRoot?: null,
      inboxMaxCount?: null
    ): NodeCreatedEventFilter;

    "NodeRejected(uint64)"(
      nodeNum?: PromiseOrValue<BigNumberish> | null
    ): NodeRejectedEventFilter;
    NodeRejected(
      nodeNum?: PromiseOrValue<BigNumberish> | null
    ): NodeRejectedEventFilter;

    "OwnerFunctionCalled(uint256)"(
      id?: PromiseOrValue<BigNumberish> | null
    ): OwnerFunctionCalledEventFilter;
    OwnerFunctionCalled(
      id?: PromiseOrValue<BigNumberish> | null
    ): OwnerFunctionCalledEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "RollupChallengeStarted(uint64,address,address,uint64)"(
      challengeIndex?: PromiseOrValue<BigNumberish> | null,
      asserter?: null,
      challenger?: null,
      challengedNode?: null
    ): RollupChallengeStartedEventFilter;
    RollupChallengeStarted(
      challengeIndex?: PromiseOrValue<BigNumberish> | null,
      asserter?: null,
      challenger?: null,
      challengedNode?: null
    ): RollupChallengeStartedEventFilter;

    "RollupInitialized(bytes32,uint256)"(
      machineHash?: null,
      chainId?: null
    ): RollupInitializedEventFilter;
    RollupInitialized(
      machineHash?: null,
      chainId?: null
    ): RollupInitializedEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;

    "UpgradedSecondary(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedSecondaryEventFilter;
    UpgradedSecondary(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedSecondaryEventFilter;

    "UserStakeUpdated(address,uint256,uint256)"(
      user?: PromiseOrValue<string> | null,
      initialBalance?: null,
      finalBalance?: null
    ): UserStakeUpdatedEventFilter;
    UserStakeUpdated(
      user?: PromiseOrValue<string> | null,
      initialBalance?: null,
      finalBalance?: null
    ): UserStakeUpdatedEventFilter;

    "UserWithdrawableFundsUpdated(address,uint256,uint256)"(
      user?: PromiseOrValue<string> | null,
      initialBalance?: null,
      finalBalance?: null
    ): UserWithdrawableFundsUpdatedEventFilter;
    UserWithdrawableFundsUpdated(
      user?: PromiseOrValue<string> | null,
      initialBalance?: null,
      finalBalance?: null
    ): UserWithdrawableFundsUpdatedEventFilter;
  };

  estimateGas: {
    _stakerMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    amountStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    anyTrustFastConfirmer(overrides?: CallOverrides): Promise<BigNumber>;

    baseStake(overrides?: CallOverrides): Promise<BigNumber>;

    bridge(overrides?: CallOverrides): Promise<BigNumber>;

    chainId(overrides?: CallOverrides): Promise<BigNumber>;

    challengeManager(overrides?: CallOverrides): Promise<BigNumber>;

    confirmPeriodBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    createNitroMigrationGenesis(
      assertion: AssertionStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    currentChallenge(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    extraChallengeTimeBlocks(overrides?: CallOverrides): Promise<BigNumber>;

    firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;

    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceRefundStaker(
      staker: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceResolveChallenge(
      stakerA: PromiseOrValue<string>[],
      stakerB: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNodeCreationBlockForLogLookup(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStaker(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStakerAddress(
      stakerNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    inbox(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isStakedOnLatestConfirmed(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isValidator(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isZombie(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;

    latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;

    latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;

    latestStakedNode(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loserStakeEscrow(overrides?: CallOverrides): Promise<BigNumber>;

    minimumAssertionPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    nodeHasStaker(
      nodeNum: PromiseOrValue<BigNumberish>,
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    outbox(overrides?: CallOverrides): Promise<BigNumber>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resume(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rollupDeploymentBlock(overrides?: CallOverrides): Promise<BigNumber>;

    rollupEventInbox(overrides?: CallOverrides): Promise<BigNumber>;

    sequencerInbox(overrides?: CallOverrides): Promise<BigNumber>;

    setAnyTrustFastConfirmer(
      _anyTrustFastConfirmer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setInbox(
      newInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakeToken(overrides?: CallOverrides): Promise<BigNumber>;

    stakerCount(overrides?: CallOverrides): Promise<BigNumber>;

    totalWithdrawableFunds(overrides?: CallOverrides): Promise<BigNumber>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeSecondaryTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeSecondaryToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validatorUtils(overrides?: CallOverrides): Promise<BigNumber>;

    validatorWalletCreator(overrides?: CallOverrides): Promise<BigNumber>;

    validatorWhitelistDisabled(overrides?: CallOverrides): Promise<BigNumber>;

    wasmModuleRoot(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawableFunds(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    zombieAddress(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    zombieCount(overrides?: CallOverrides): Promise<BigNumber>;

    zombieLatestStakedNode(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _stakerMap(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    amountStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    anyTrustFastConfirmer(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    baseStake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    chainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    challengeManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    confirmPeriodBlocks(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createNitroMigrationGenesis(
      assertion: AssertionStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    currentChallenge(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    extraChallengeTimeBlocks(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    firstUnresolvedNode(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceRefundStaker(
      staker: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceResolveChallenge(
      stakerA: PromiseOrValue<string>[],
      stakerB: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNodeCreationBlockForLogLookup(
      nodeNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStaker(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStakerAddress(
      stakerNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    inbox(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isStaked(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStakedOnLatestConfirmed(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isValidator(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isZombie(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastStakeBlock(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    latestConfirmed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    latestNodeCreated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    latestStakedNode(
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loserStakeEscrow(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minimumAssertionPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nodeHasStaker(
      nodeNum: PromiseOrValue<BigNumberish>,
      staker: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    outbox(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resume(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rollupDeploymentBlock(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rollupEventInbox(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sequencerInbox(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAnyTrustFastConfirmer(
      _anyTrustFastConfirmer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setInbox(
      newInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakeToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stakerCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalWithdrawableFunds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeSecondaryTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeSecondaryToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validatorUtils(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    validatorWalletCreator(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    validatorWhitelistDisabled(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    wasmModuleRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawableFunds(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    zombieAddress(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    zombieCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    zombieLatestStakedNode(
      zombieNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
