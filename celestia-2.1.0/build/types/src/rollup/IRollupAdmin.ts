/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export type GlobalStateStruct = {
  bytes32Vals: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>];
  u64Vals: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>];
};

export type GlobalStateStructOutput = [
  [string, string],
  [BigNumber, BigNumber]
] & { bytes32Vals: [string, string]; u64Vals: [BigNumber, BigNumber] };

export type ExecutionStateStruct = {
  globalState: GlobalStateStruct;
  machineStatus: PromiseOrValue<BigNumberish>;
};

export type ExecutionStateStructOutput = [GlobalStateStructOutput, number] & {
  globalState: GlobalStateStructOutput;
  machineStatus: number;
};

export type AssertionStruct = {
  beforeState: ExecutionStateStruct;
  afterState: ExecutionStateStruct;
  numBlocks: PromiseOrValue<BigNumberish>;
};

export type AssertionStructOutput = [
  ExecutionStateStructOutput,
  ExecutionStateStructOutput,
  BigNumber
] & {
  beforeState: ExecutionStateStructOutput;
  afterState: ExecutionStateStructOutput;
  numBlocks: BigNumber;
};

export type ConfigStruct = {
  confirmPeriodBlocks: PromiseOrValue<BigNumberish>;
  extraChallengeTimeBlocks: PromiseOrValue<BigNumberish>;
  stakeToken: PromiseOrValue<string>;
  baseStake: PromiseOrValue<BigNumberish>;
  wasmModuleRoot: PromiseOrValue<BytesLike>;
  owner: PromiseOrValue<string>;
  loserStakeEscrow: PromiseOrValue<string>;
  chainId: PromiseOrValue<BigNumberish>;
  chainConfig: PromiseOrValue<string>;
  genesisBlockNum: PromiseOrValue<BigNumberish>;
  sequencerInboxMaxTimeVariation: ISequencerInbox.MaxTimeVariationStruct;
};

export type ConfigStructOutput = [
  BigNumber,
  BigNumber,
  string,
  BigNumber,
  string,
  string,
  string,
  BigNumber,
  string,
  BigNumber,
  ISequencerInbox.MaxTimeVariationStructOutput
] & {
  confirmPeriodBlocks: BigNumber;
  extraChallengeTimeBlocks: BigNumber;
  stakeToken: string;
  baseStake: BigNumber;
  wasmModuleRoot: string;
  owner: string;
  loserStakeEscrow: string;
  chainId: BigNumber;
  chainConfig: string;
  genesisBlockNum: BigNumber;
  sequencerInboxMaxTimeVariation: ISequencerInbox.MaxTimeVariationStructOutput;
};

export type ContractDependenciesStruct = {
  bridge: PromiseOrValue<string>;
  sequencerInbox: PromiseOrValue<string>;
  inbox: PromiseOrValue<string>;
  outbox: PromiseOrValue<string>;
  rollupEventInbox: PromiseOrValue<string>;
  challengeManager: PromiseOrValue<string>;
  rollupAdminLogic: PromiseOrValue<string>;
  rollupUserLogic: PromiseOrValue<string>;
  validatorUtils: PromiseOrValue<string>;
  validatorWalletCreator: PromiseOrValue<string>;
};

export type ContractDependenciesStructOutput = [
  string,
  string,
  string,
  string,
  string,
  string,
  string,
  string,
  string,
  string
] & {
  bridge: string;
  sequencerInbox: string;
  inbox: string;
  outbox: string;
  rollupEventInbox: string;
  challengeManager: string;
  rollupAdminLogic: string;
  rollupUserLogic: string;
  validatorUtils: string;
  validatorWalletCreator: string;
};

export declare namespace ISequencerInbox {
  export type MaxTimeVariationStruct = {
    delayBlocks: PromiseOrValue<BigNumberish>;
    futureBlocks: PromiseOrValue<BigNumberish>;
    delaySeconds: PromiseOrValue<BigNumberish>;
    futureSeconds: PromiseOrValue<BigNumberish>;
  };

  export type MaxTimeVariationStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    delayBlocks: BigNumber;
    futureBlocks: BigNumber;
    delaySeconds: BigNumber;
    futureSeconds: BigNumber;
  };
}

export interface IRollupAdminInterface extends utils.Interface {
  functions: {
    "forceConfirmNode(uint64,bytes32,bytes32)": FunctionFragment;
    "forceCreateNode(uint64,uint256,(((bytes32[2],uint64[2]),uint8),((bytes32[2],uint64[2]),uint8),uint64),bytes32)": FunctionFragment;
    "forceRefundStaker(address[])": FunctionFragment;
    "forceResolveChallenge(address[],address[])": FunctionFragment;
    "initialize((uint64,uint64,address,uint256,bytes32,address,address,uint256,string,uint64,(uint256,uint256,uint256,uint256)),(address,address,address,address,address,address,address,address,address,address))": FunctionFragment;
    "pause()": FunctionFragment;
    "removeOldOutbox(address)": FunctionFragment;
    "resume()": FunctionFragment;
    "setBaseStake(uint256)": FunctionFragment;
    "setConfirmPeriodBlocks(uint64)": FunctionFragment;
    "setDelayedInbox(address,bool)": FunctionFragment;
    "setExtraChallengeTimeBlocks(uint64)": FunctionFragment;
    "setLoserStakeEscrow(address)": FunctionFragment;
    "setMinimumAssertionPeriod(uint256)": FunctionFragment;
    "setOutbox(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "setSequencerInbox(address)": FunctionFragment;
    "setStakeToken(address)": FunctionFragment;
    "setValidator(address[],bool[])": FunctionFragment;
    "setValidatorWhitelistDisabled(bool)": FunctionFragment;
    "setWasmModuleRoot(bytes32)": FunctionFragment;
    "upgradeBeacon(address,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "forceConfirmNode"
      | "forceCreateNode"
      | "forceRefundStaker"
      | "forceResolveChallenge"
      | "initialize"
      | "pause"
      | "removeOldOutbox"
      | "resume"
      | "setBaseStake"
      | "setConfirmPeriodBlocks"
      | "setDelayedInbox"
      | "setExtraChallengeTimeBlocks"
      | "setLoserStakeEscrow"
      | "setMinimumAssertionPeriod"
      | "setOutbox"
      | "setOwner"
      | "setSequencerInbox"
      | "setStakeToken"
      | "setValidator"
      | "setValidatorWhitelistDisabled"
      | "setWasmModuleRoot"
      | "upgradeBeacon"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "forceConfirmNode",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceCreateNode",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      AssertionStruct,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "forceRefundStaker",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "forceResolveChallenge",
    values: [PromiseOrValue<string>[], PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [ConfigStruct, ContractDependenciesStruct]
  ): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "removeOldOutbox",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "resume", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setBaseStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setConfirmPeriodBlocks",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setDelayedInbox",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setExtraChallengeTimeBlocks",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setLoserStakeEscrow",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinimumAssertionPeriod",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOutbox",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSequencerInbox",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakeToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setValidator",
    values: [PromiseOrValue<string>[], PromiseOrValue<boolean>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setValidatorWhitelistDisabled",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setWasmModuleRoot",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeBeacon",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "forceConfirmNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceCreateNode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceRefundStaker",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceResolveChallenge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeOldOutbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resume", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBaseStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setConfirmPeriodBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDelayedInbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExtraChallengeTimeBlocks",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setLoserStakeEscrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinimumAssertionPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOutbox", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setSequencerInbox",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setValidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setValidatorWhitelistDisabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setWasmModuleRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeBeacon",
    data: BytesLike
  ): Result;

  events: {
    "OwnerFunctionCalled(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnerFunctionCalled"): EventFragment;
}

export interface OwnerFunctionCalledEventObject {
  id: BigNumber;
}
export type OwnerFunctionCalledEvent = TypedEvent<
  [BigNumber],
  OwnerFunctionCalledEventObject
>;

export type OwnerFunctionCalledEventFilter =
  TypedEventFilter<OwnerFunctionCalledEvent>;

export interface IRollupAdmin extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IRollupAdminInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceRefundStaker(
      stacker: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceResolveChallenge(
      stackerA: PromiseOrValue<string>[],
      stackerB: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resume(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  forceConfirmNode(
    nodeNum: PromiseOrValue<BigNumberish>,
    blockHash: PromiseOrValue<BytesLike>,
    sendRoot: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceCreateNode(
    prevNode: PromiseOrValue<BigNumberish>,
    prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
    assertion: AssertionStruct,
    expectedNodeHash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceRefundStaker(
    stacker: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceResolveChallenge(
    stackerA: PromiseOrValue<string>[],
    stackerB: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    config: ConfigStruct,
    connectedContracts: ContractDependenciesStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  removeOldOutbox(
    _outbox: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resume(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBaseStake(
    newBaseStake: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setConfirmPeriodBlocks(
    newConfirmPeriod: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDelayedInbox(
    _inbox: PromiseOrValue<string>,
    _enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setExtraChallengeTimeBlocks(
    newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setLoserStakeEscrow(
    newLoserStakerEscrow: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMinimumAssertionPeriod(
    newPeriod: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOutbox(
    _outbox: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSequencerInbox(
    _sequencerInbox: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakeToken(
    newStakeToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setValidator(
    _validator: PromiseOrValue<string>[],
    _val: PromiseOrValue<boolean>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setValidatorWhitelistDisabled(
    _validatorWhitelistDisabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setWasmModuleRoot(
    newWasmModuleRoot: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeBeacon(
    beacon: PromiseOrValue<string>,
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceRefundStaker(
      stacker: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    forceResolveChallenge(
      stackerA: PromiseOrValue<string>[],
      stackerB: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    pause(overrides?: CallOverrides): Promise<void>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    resume(overrides?: CallOverrides): Promise<void>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "OwnerFunctionCalled(uint256)"(
      id?: PromiseOrValue<BigNumberish> | null
    ): OwnerFunctionCalledEventFilter;
    OwnerFunctionCalled(
      id?: PromiseOrValue<BigNumberish> | null
    ): OwnerFunctionCalledEventFilter;
  };

  estimateGas: {
    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceRefundStaker(
      stacker: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceResolveChallenge(
      stackerA: PromiseOrValue<string>[],
      stackerB: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resume(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    forceConfirmNode(
      nodeNum: PromiseOrValue<BigNumberish>,
      blockHash: PromiseOrValue<BytesLike>,
      sendRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceCreateNode(
      prevNode: PromiseOrValue<BigNumberish>,
      prevNodeInboxMaxCount: PromiseOrValue<BigNumberish>,
      assertion: AssertionStruct,
      expectedNodeHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceRefundStaker(
      stacker: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceResolveChallenge(
      stackerA: PromiseOrValue<string>[],
      stackerB: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      config: ConfigStruct,
      connectedContracts: ContractDependenciesStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    removeOldOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resume(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBaseStake(
      newBaseStake: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setConfirmPeriodBlocks(
      newConfirmPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDelayedInbox(
      _inbox: PromiseOrValue<string>,
      _enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setExtraChallengeTimeBlocks(
      newExtraTimeBlocks: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setLoserStakeEscrow(
      newLoserStakerEscrow: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMinimumAssertionPeriod(
      newPeriod: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOutbox(
      _outbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSequencerInbox(
      _sequencerInbox: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakeToken(
      newStakeToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setValidator(
      _validator: PromiseOrValue<string>[],
      _val: PromiseOrValue<boolean>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setValidatorWhitelistDisabled(
      _validatorWhitelistDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setWasmModuleRoot(
      newWasmModuleRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeBeacon(
      beacon: PromiseOrValue<string>,
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
